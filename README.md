# Тестовое задание

## Запуск

1. Для запуска приложения нужно создать файл .env в корневой директории проекта и задать необходимый конфигурационные переменные. Пример:
    ```
    HOST=0.0.0.0
    PORT=8080
    INMEM=false
    POSTGRES_HOST=postgres
    POSTGRES_PORT=5432
    POSTGRES_USER=postgres
    POSTGRES_PASSWORD=postgres123
    POSTGRES_DB=posts
    ```

2. Если будет использоваться хранилище Postgres, то нужно создать там нужного пользователя, задать пароль и создать БД. Затме нужно поднять хранилище и накатить миграции на схему.

    Поднять БД:

    ```$ make run-local-storage```

    -Накатить миграции:

    ```$ make migrations-up```

    *(Откатить миграции):

    *```$ make migrations-up```

    Остановить контейнер:

    ```$ make stop-local-storage```

2. Для запуска сервиса в докер контейнере выполнить команду:
    
    ```$ make run```

    Остановка:

    ```$ make stop```

3. Если нужно запустить сервис локально не в контейнере:

    При необходимости поднять БД:

    ```$ make run-local-storage```

    Запустить сервис:

    ```$ make run-local```

    Остановка БД:

    ```$make stop-local-storage```

## Реализация

Сервис реализован польностью на *Go*. При разработке я старался придерживаться чистой архитектуры приложения, грамотно разделяя приложение на слои и пакеты.

Реализованное API соотвествует [заданию](/doc/task.pdf) и предоставляет весь функционал, в том числе и асинхронную доставку новых комментариев к посту для подписанных пользователей.

Приложение предоставляет выбор хранилища: *inmemory* либо *Postgres*. Для *sql* миграций *Postgres* я использовал утилиту [goose](https://github.com/pressly/goose). При реализации *inmemory* хранилища я постарался сделать эффективную реализацию, которая позволяет быстро вставлять/искать/удалять объекты.

Для работы с GraphQL я исползовал библиотеку [gqlgen](https://gqlgen.com/), которая позволяет сгенерировать нужные типы данных, резолверы и сериалайзеры по существующей *.graphql* схеме. Схемы описаны в директории [/graphql](/graphql/), сгенерированный код в директории */gen*.

Для тестирования можно использовать удобный UI от gqlgen.Playground, а так же можно импортировать graphql схему в postman и тестировать запросы там.

Схема и резолверы выполенены таким образом, что клиент может запрашивать комментарии к посту и ответы на него в с неограниченной вложенностью, однако для управления обработкой больших запросов я устанавлию timeout ограничение, которое не позволит серверу упасть. При обработке websocket соединения для подписанных клиентов этот таймаут, очевидно, не используется.
